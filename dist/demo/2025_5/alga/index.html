<style>
  body {
    --main-color: #079267;
    color: #093f2a;
    background: #e7eceb;
    font-family: sans-serif;
    font-size: 20px;
    max-width: 700px;
    margin: 20px auto;
    line-height: 1.5;
  }
  li {
    margin: 10px 0;
  }
  hr {
    border: 0.5px solid var(--main-color);
    margin: 50px 0;
  }
  @media (max-width: 700px) {
    body {
      margin: 20px 10px;
    }
  }
  pre {
    font-family: "fira code";
    white-space: pre-wrap;
  }

  a:visited {
    color: var(--main-color);
  }
  a:hover {
    color: var(--main-color);
  }
  a:link {
    color: var(--main-color);
  }
  a:active {
    color: var(--main-color);
  }
</style>

<h1>Alga</h1>
<div>May 2 2025</div>

<p>
  This note is about Alga. The
  <a href="./alga_core.js">core</a> of alga is really about a certain funky sort
  of multidirectional computation, but it was designed to solve some layout
  language problems. In particular, it was designed to implement a relational
  layout combinator API similar to (and based on)
  <a href="https://bluefishjs.org/">Bluefish</a>'s with some additional
  properties I wanted.
</p>
<img src="./layers.svg" />
<p>
  Alga has three layers, the core, the layout API, and the renderer-specific
  API. So far I've only made a
  <a
    href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
    >canvas-2D</a
  >-specific <a href="./alga_canvas.js">API</a>, but I think it would only take
  a couple hours to make an HTML or SVG or WebGL one.
</p>
<p>
  Alga core's multidirectional evaluation makes it effective for expressing
  direct-manipulable layouts. You can change any part of the layout, and any
  related parts of the diagram will be recomputed to respect relationships.
</p>

<p>Check out an example:</p>
<canvas
  id="c1"
  style="
    background: white;
    border-radius: 18px 18px 0 0;
    outline: 1px solid var(--main-color);
  "
></canvas>
<script type="module">
  const c = document.getElementById("c1");
  const ctx = c.getContext("2d");
  import {
    left,
    right,
    top,
    bottom,
    Point,
    Group,
    spaceY,
    eq,
    centerBottom,
    centerTop,
    leftTop,
    rightTop,
    leftCenter,
    rightCenter,
  } from "./alga_api.js";
  import { d } from "./alga_canvas.js";

  // make things crispy
  const dpr = window.devicePixelRatio;
  const cw = 300;
  const ch = 300;
  c.width = cw * dpr;
  c.height = ch * dpr;
  c.style.width = cw + "px";
  c.style.height = ch + "px";
  ctx.scale(dpr, dpr);

  const {
    draw,
    Box,
    Outline,
    DraggableBox,
    DraggableOutline,
    deleteDrawable,
    Text,
    Line,
  } = d(ctx);

  const b1 = DraggableBox("yellowgreen");
  const b2 = DraggableBox("orangered");
  const b3 = DraggableBox("violet");
  const b4 = DraggableBox("cornflowerblue");

  b2.left = b1.right + 5;
  b4.left = b3.right + 5;

  const g1 = Outline(b1, b2);
  const g2 = Outline(b3, b4);

  g2.top = g1.bottom.plus(15);

  g1.top = 20;
  g1.left = 20;
  Line(g1.centerBottom, g2.centerTop);

  function anim() {
    requestAnimationFrame(anim);
    ctx.clearRect(0, 0, c.width, c.height);
    draw();
  }
  anim();
</script>
<br />
<pre
  style="
    font-size: 14px;
    background: white;
    padding: 12px;
    border-radius: 0 18px 18px 18px;
    outline: 1px solid var(--main-color);
  "
>
// imports and canvas set-up are not shown in this code

const b1 = DraggableBox("yellowgreen");
const b2 = DraggableBox("orangered");
const b3 = DraggableBox("violet");
const b4 = DraggableBox("cornflowerblue");
<span style='color: orangered'>b2.left = b1.right + 5; //one-time set</span>
<span style='color: orangered'>b4.left = b3.right + 5; //one-time set</span>
const g1 = Outline(b1, b2);
const g2 = Outline(b3, b4);
<span style='color: var(--main-color)'>g2.top = g1.bottom.plus(15); //set and create relationship</span>
<span style='color: orangered'>g1.leftTop = [20, 20]; //one-time set</span>
Line(g1.centerBottom, g2.centerTop);
</pre>
<hr />
<canvas
  id="c"
  height="700"
  width="700"
  style="
    background: white;
    border-radius: 18px;
    outline: 1px solid var(--main-color);
  "
></canvas>
<script type="module">
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  import {
    Point,
    Group,
    spaceX,
    spaceY,
    eq,
    eq2,
    stackX,
    stackY,
    rel,
    lessThan,
  } from "../../2025_5/alga/alga_api.js";
  import { d } from "../../2025_5/alga/alga_canvas.js";

  // make things crispy
  const dpr = window.devicePixelRatio;
  const h = c.height;
  const w = c.width;
  c.width = w * dpr;
  c.height = h * dpr;
  c.style.width = w + "px";
  c.style.height = h + "px";
  ctx.scale(dpr, dpr);

  const {
    draw,
    Box,
    Outline,
    Arrow,
    DraggableBox,
    DraggableOutline,
    deleteDrawable,
    Text,
    Line,
  } = d(ctx);

  const txtInit = DraggableBox();
  let txtL = Group(txtInit);
  let txtO = Outline(txtL);
  let txtHead = txtInit;
  txtInit.leftTop = [250, 200];
  // next:
  // - better text rendering
  // - backspace (deleting object from group)
  // - left and right careting (along Arrows somehow?)
  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const newTxtInit = DraggableBox("red", 10, 10);
      const newTxtL = Group(newTxtInit);
      stackY(5, 0)(txtL, newTxtL);

      Arrow(txtHead.centerBottom, newTxtInit.centerTop);
      txtL = newTxtL;
      txtHead = newTxtInit;

      deleteDrawable(txtO);
      txtO = Outline(txtL);
      // what if this automatically outlined whatever txtO pointed at?
    } else {
      const newHead = Text(e.key);
      stackX(8)(txtHead, newHead);

      txtL.add(newHead);
      Arrow(txtHead.rightCenter, newHead.leftCenter);
      txtHead = newHead;
    }
  });
  // what if this text was in a group and the group auto-expanded?

  const exp = (numD, expD) => {
    eq2(numD.rightTop, expD.leftCenter);
    return Group(numD, expD);
  };
  const FRAC_GAP = 8;
  const frac = (numD, denD) => {
    const g = stackY(FRAC_GAP)(numD, denD);
    const l = Line();
    l.left = g.left;
    l.right = g.right;
    l.top = numD.bottom.plus(FRAC_GAP / 2);
    l.bottom = l.top;
    return g;
  };
  const sum = (topD, bottomD, rightD) => {
    const Σ = Text("Σ", 40);
    stackX()(Σ, rightD);
    stackY(3)(topD, Σ);
    stackY(5)(Σ, bottomD);
    return Group(Σ, topD, bottomD, rightD);
  };

  const g = stackX(0)(
    Text("ζ(s) = "),
    sum(
      Text("∞", 22),
      Text("n=0"),
      frac(Text("1"), exp(Text("n"), Text("s", 12)))
    )
  );
  DraggableOutline(g);
  g.leftTop = [30, 30];

  const boundingExperimentF = () => {
    const b1 = DraggableBox("yellowgreen");
    const b2 = DraggableBox("orangered");
    const b3 = DraggableBox("violet");
    const b4 = DraggableBox("cornflowerblue");
    b2.left = 20;
    b4.left = 20;
    const g1 = Outline(b1, b2);
    const g2 = Outline(b3, b4);
    const boundingExperiment = spaceY(20)(g1, g2);
    Line(g1.centerBottom, g2.centerTop);
    DraggableOutline(boundingExperiment);
    boundingExperiment.left = 30;
    boundingExperiment.top = 130;
  };
  boundingExperimentF();

  const dagNode = (...sts) => {
    const node = DraggableBox("orange");
    node.t = node;
    node.next = sts.map((st) => st.t);

    for (const subt of sts) Line(node.centerBottom, subt.t.centerTop);

    const subts = sts.filter((subt) => !subt.parent);
    if (subts.length === 0) return node;
    for (const subt of subts) subt.parent = node;

    const subtsBox = spaceX(20)(...subts);
    eq(subtsBox.left, node.left);

    const res = spaceY(30)(node, Group(...subts));
    res.t = node;

    return res;
  };

  // actually a DAG
  const minNode = dagNode();
  const subDag1 = dagNode(dagNode(dagNode(minNode), dagNode(minNode)));
  const subDag2 = dagNode(dagNode(dagNode(minNode), dagNode(minNode)));
  const myDag = dagNode(
    dagNode(subDag1),
    dagNode(subDag1),
    dagNode(subDag1, subDag2)
  );

  DraggableOutline(myDag);
  myDag.left = 30;
  myDag.top = 230;

  const a0 = DraggableBox("orange");
  const b0 = DraggableBox("orange");
  const b1 = DraggableBox("orange");
  const b2 = DraggableBox("orange");
  const c0 = DraggableBox("orange");
  const c1 = DraggableBox("orange");
  Arrow(a0.centerTop, b0.centerTop);
  Arrow(a0.centerTop, b1.centerTop);
  Arrow(a0.centerTop, b2.centerTop);
  Arrow(b0.centerTop, c0.centerTop);
  Arrow(b1.centerTop, c0.centerTop);
  Arrow(b2.centerTop, c0.centerTop);
  Arrow(b2.centerTop, c1.centerTop);

  DraggableOutline(a0, b0, b1, b2, c0, c1).leftTop = [300, 20];

  spaceX(20)(b0, b1, b2);
  spaceX(55)(c0, c1);
  eq(a0.left, b0.left);
  eq(b0.left, c0.left);
  spaceY()(a0, Group(b0, b1, b2));
  spaceY()(Group(b0, b1, b2), c0);
  spaceY()(b2, c1);

  const m00 = DraggableBox("yellowgreen");
  const m10 = DraggableBox("salmon");
  const m11 = DraggableBox("goldenrod");
  Outline(Group(m10, m11)).left = Outline(m00).right.plus(10);
  m10.top = 600;
  m11.top += 20;
  DraggableOutline(m00, m11).top = 500;

  const D = DraggableBox;
  const tt0 = D("red");
  const tt02 = D("orangered");
  const tt1 = D("red");
  const tt12 = D("orangered");
  const tt2 = D("red");
  const tt22 = D("orangered");
  const gg0 = Group(tt0, tt02);
  const gg1 = Group(tt1, tt12);
  const gg2 = Group(tt2, tt22);
  gg0.left = gg1.right.plus(15);
  gg1.left = gg2.right.plus(15);
  const ggg = DraggableOutline(tt0, tt1);
  tt1.left = 500;
  tt02.left = 500;
  tt12.left = 500;
  tt22.left = 500;
  tt2.top = 200;
  tt1.top = 200;
  tt0.top = 200;

  const bb1 = DraggableBox("yellowgreen");
  const bb2 = DraggableBox("crimson");
  const bb22 = DraggableBox("orange");
  bb22.top = 18;
  const bb3 = DraggableBox("violet");

  lessThan(bb1.x.r.plus(10), bb2.x.l);
  lessThan(bb1.x.r.plus(10), bb22.x.l);
  lessThan(bb2.x.r.plus(10), bb3.x.l);
  lessThan(bb22.x.r.plus(10), bb3.x.l);
  lessThan(bb2.y.r.plus(10), bb1.y.l);
  lessThan(bb2.y.r.plus(10), bb3.y.l);
  lessThan(bb1.y.r.plus(10), bb22.y.l);
  lessThan(bb3.y.r.plus(10), bb22.y.l);

  const bbg = DraggableOutline(bb1, bb2, bb22, bb3);
  bbg.top = 300;
  bbg.left = 300;

  (() => {
    const num = DraggableBox("gray");
    const denom = DraggableBox("gray");
    const numG = Group(num);
    const denomG = Group(denom);
    frac(numG, denomG).leftTop = [400, 400];
  })();

  function anim() {
    requestAnimationFrame(anim);
    ctx.clearRect(0, 0, c.width, c.height);
    draw();
  }
  anim();
</script>
