<!-- #region -->
<style>
  body {
    --main-color: #ca2b6d;
    color: #060a1b;
    background: white;
    font-family: sans-serif;
    font-size: 16px;
    max-width: 700px;
    margin: 20px auto;
  }
  li {
    margin: 10px 0;
  }
  hr {
    margin: 50px 0;
  }
  pre {
    font-family: "fira code";
    white-space: pre-wrap;
  }
  canvas,
  img {
    border-radius: 10px;
  }
  @media (max-width: 700px) {
    body {
      margin: 20px 10px;
    }
  }
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<h1><a href="../exploring_spaces/">Exploring Spaces</a> 4: Sphere</h1>
<a href="https://elliot.website">elliot evans<br /></a>
May 13 2024<br /><br />

<audio controls>
  <source src="./recording.mp3" type="audio/mpeg" />
  Your browser does not support the audio element.
</audio>
<!-- #endregion -->

<section>
  <h2>Taping a Rectangle into a Sphere</h2>

  In <a href="../exploring_spaces/">previous Exploring Spaces</a>, we explored
  how to tape a rectangle into:
  <span>
    <ul>
      <li>a Torus,</li>
      <li>a Twisted Strip, and</li>
      <li>a Real Projective Plane.</li>
    </ul>
  </span>

  <svg
    viewBox="-40 -40 280 280"
    width="200"
    id="dragging4"
    style="float: left; margin-right: 20px"
  >
    <defs>
      <marker
        id="head"
        orient="auto"
        markerWidth="3"
        markerHeight="4"
        refX="0.1"
        refY="2"
      >
        <path d="M0,0 V4 L3,2 Z" fill="red" />
      </marker>
      <marker
        id="head_blue"
        orient="auto"
        markerWidth="3"
        markerHeight="4"
        refX="0.1"
        refY="2"
      >
        <path d="M0,0 V4 L3,2 Z" fill="blue" />
      </marker>
    </defs>
    <g transform="rotate(45, 100, 100)">
      <mask id="rectmask">
        <rect width="200" height="200" rx="10" fill="white" />
      </mask>
      <rect width="200" height="200" rx="10" fill="#eee" />

      <path
        marker-end="url(#head)"
        stroke-width="4"
        fill="none"
        stroke="red"
        d="M0,0, 187,0"
      />
      <path
        marker-end="url(#head_blue)"
        stroke-width="4"
        fill="none"
        stroke="blue"
        d="M0,200, 187,200"
      />
      <path
        marker-end="url(#head)"
        stroke-width="4"
        fill="none"
        stroke="red"
        d="M0,0, 0,187"
      />
      <path
        marker-end="url(#head_blue)"
        stroke-width="4"
        fill="none"
        stroke="blue"
        d="M200,0, 200,187"
      />

      <circle class="draggable x y" r="14" mask="url(#rectmask)"></circle>
    </g>
  </svg>
  <script type="module" src="./dragging4.js"></script>
  <style>
    #dragging4 circle {
      stroke: black;
      stroke-width: 3px;
    }
    #dragging4 .draggable {
      cursor: grab;
      fill: white;
    }
    #dragging4 .dragging {
      cursor: grabbing;
      fill: hsl(200, 54%, 76%);
    }
  </style>

  Now, a diagram showing how to tape a rectangle into a sphere. I rotated the
  rectangle. The top is like the north pole and the bottom is like the south
  pole.
  <img
    src="./dumpling.png"
    style="float: right; width: 215px; margin: 10px"
  /><br /><br />

  I tried taping a rectangle into a sphere in real life. It ended up more like a
  puffy triangle / dumpling than a round sphere üòï.<br /><br />

  It's okay! When we are talking about topology, as long as it wraps around like
  a sphere, its a sphere.
</section>

<section style="float: left; width: 100%">
  <h2>Colour Picker</h2>

  <span style="float: left; margin: 10px">
    <svg
      viewBox="-52 -52 104 104"
      width="200"
      id="dragging2a"
      style="float: left"
    >
      <defs>
        <mask id="hole">
          <rect width="114" height="114" fill="white" x="-62" y="-62" />
          <circle r="50" fill="black" />
        </mask>
      </defs>

      <rect
        id="dragging2a_background_rect"
        width="114"
        height="114"
        fill="white"
        x="-62"
        y="-62"
        mask="url(#hole)"
        style="pointer-events: none"
      />
      <circle cx="0" cy="0" r="50" fill="#eee"></circle>
      <circle
        id="dragging2a_border"
        cx="0"
        cy="0"
        r="50"
        fill="none"
        stroke="black"
        stroke-width="2"
      ></circle>
    </svg>
    <svg
      viewBox="-52 -52 104 104"
      width="200"
      id="dragging2b"
      style="float: left"
    >
      <defs>
        <mask id="hole">
          <rect width="104" height="104" fill="white" x="-52" y="-52" />
          <circle r="50" fill="black" />
        </mask>
      </defs>
      <rect
        id="dragging2b_background_rect"
        width="104"
        height="104"
        fill="white"
        x="-52"
        y="-52"
        mask="url(#hole)"
        style="pointer-events: none"
      />
      <circle cx="0" cy="0" r="50" fill="#eee"></circle>
      <circle
        id="dragging2b_border"
        cx="0"
        cy="0"
        r="50"
        fill="none"
        stroke="black"
        stroke-width="2"
        stroke-dasharray="8"
      ></circle>
    </svg>
    <style>
      svg {
        background: white;
      }
      .draggable {
        stroke: black;
        stroke-width: 2px;
        cursor: grab;
        fill: white;
      }
      .dragging {
        cursor: grabbing;
        fill: hsl(200, 54%, 76%) !important;
      }
    </style>
    <script type="module" src="./dragging2.js"></script>
  </span>

  Here is a colour picker. It is made out of two circles with connected
  boundaries. <br /><br />

  Try dragging the input circle
  <svg viewbox="-12 -12 24 24" width="16" style="vertical-align: middle">
    <circle r="9" fill="white" stroke="black" stroke-width="4"></circle>
  </svg>
  across a boundary.<br /><br />

  These two circles together wrap around like a sphere. The left circle is like
  the front of the sphere, and the right circle is like the back.<br /><br />

  If you remember <a href="../exploring_spaces_2/">Twisted Taping</a>, you may
  have noticed that the circular Real Projective Plane input wraps around in a
  similar way to these two circles. If so, you are on to an interesting
  relationship called a double covering, but I will have to talk about that in
  another article.
</section>

<section style="float: left; width: 100%">
  <canvas
    id="sphereCanvas"
    height="220"
    width="220"
    style="float: right"
  ></canvas>
  <script type="module" src="./sphereCanvas.js"></script>
  <h2>But what does "wraps around like" mean?</h2>
  We just took a look at two inputs: the rectangle that wraps around like a
  sphere, and the color picker that wraps around like a sphere.<br /><br />
  The input circle
  <svg viewbox="-12 -12 24 24" width="16" style="vertical-align: middle">
    <circle r="9" fill="white" stroke="black" stroke-width="4"></circle>
  </svg>
  is synchronized across both of these inputs: if you drag the input circle
  <svg viewbox="-12 -12 24 24" width="16" style="vertical-align: middle">
    <circle r="9" fill="white" stroke="black" stroke-width="4"></circle>
  </svg>
  in one input, it also moves in the other input. The synchronization respects
  how each input wraps around, and the point never jumps or teleports.<br /><br />
  In Topology, this kind of synchronization relationship is called a
  <strong>homeomorphism</strong>. If you can synchronize two input spaces with a
  homeomorphism, then they are called homeomorphic, and they're topologically
  the same space.<br /><br />Any space that wraps around like (is homeomorphic
  to) a sphere, is a sphere!
</section>

<!-- #region -->
<div style="clear: both"></div>
<h2 id="comments">Exploring Spaces Comments</h2>
<textarea
  id="commenttext1"
  style="width: 100%; height: 80px"
  placeholder="Hi, I'm [name]. You are a bit wrong about [blank]. I liked [blank]. [blank] didn't make sense, could you clarify? There's a bug!"
></textarea>
<button id="commentbutton1">Submit comment</button>
<div id="commentarea"></div>
<script type="module">
  const MY_FORKED_VAL_URL = "https://vez-tomatoSalmon.web.val.run/";

  const getComments = async () => {
    const response = await fetch(MY_FORKED_VAL_URL);
    const json = await response.json();
    return json;
  };

  const addComment = async (str) => {
    try {
      const response = await fetch(MY_FORKED_VAL_URL, {
        method: "POST",
        body: JSON.stringify(str),
      });

      if (response.status >= 400 && response.status < 600) {
        /* error */
        return false;
      } else {
        /* success */
        return true;
      }
    } catch (e) {
      /* error */
      return false;
    }
  };

  function appendComment(str) {
    const div = document.createElement("div");
    div.style.display = "block";
    div.style.margin = "10px 0";
    div.style.background = "#eee";
    div.style.padding = "10px";
    div.style.borderRadius = "10px";
    div.textContent = str;
    document.getElementById("commentarea").append(div);
  }

  (await getComments()).forEach(appendComment);

  const text = document.getElementById("commenttext1");
  const button = document.getElementById("commentbutton1");
  button.addEventListener("click", async () => {
    const value = text.value;

    button.textContent = "üîÑ";
    const success = await addComment(value);
    if (success === false) {
      button.textContent =
        "‚ùå error (sorry theres no details or error reporting yet)";
    } else {
      button.textContent = "‚úÖ";
      button.disabled = true;
      text.disabled = true;
      text.value = "";
      appendComment(value);
    }
  });
</script>
<!-- #endregion -->
