<style>
  body {
    --main-color: #079267;
    color: #093f2a;
    background: #e7eceb;
    font-family: sans-serif;
    font-size: 20px;
    max-width: 700px;
    margin: 20px auto;
    line-height: 1.5;
  }
  li {
    margin: 10px 0;
  }
  hr {
    border: 0.5px solid var(--main-color);
    margin: 50px 0;
  }
  @media (max-width: 700px) {
    body {
      margin: 20px 10px;
    }
  }
  pre {
    font-family: "fira code";
    white-space: pre-wrap;
  }

  a:visited {
    color: var(--main-color);
  }
  a:hover {
    color: var(--main-color);
  }
  a:link {
    color: var(--main-color);
  }
  a:active {
    color: var(--main-color);
  }
</style>

<h1>Alga</h1>
<div>May 2 2025</div>

<p>
  This note is about Alga. The
  <a href="./alga_core.js">core</a> of alga is really about a certain funky sort
  of multidirectional computation, but it was designed to solve some layout
  language problems. In particular, it was designed to implement a relational
  layout combinator API similar to (and based on)
  <a href="https://bluefishjs.org/">Bluefish</a>'s with some additional
  properties I wanted.
</p>
<img src="./layers.svg" />
<p>
  Alga has three layers, the core, the layout API, and the renderer-specific
  API. So far I've only made a
  <a
    href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D"
    >canvas-2D</a
  >-specific <a href="./alga_canvas.js">API</a>, but I think it would only take
  a couple hours to make an HTML or SVG or WebGL one.
</p>
<p>
  Alga core's multidirectional evaluation makes it effective for expressing
  direct-manipulable layouts. You can change any part of the layout, and any
  related parts of the diagram will be recomputed to respect relationships.
</p>

<p>Check out an example:</p>
<canvas
  id="c1"
  style="
    background: white;
    border-radius: 18px 18px 0 0;
    outline: 1px solid var(--main-color);
  "
></canvas>
<script type="module">
  const c = document.getElementById("c1");
  const ctx = c.getContext("2d");
  import {
    left,
    right,
    top,
    bottom,
    Point,
    Group,
    spaceY,
    eq,
    centerBottom,
    centerTop,
    leftTop,
    rightTop,
    leftCenter,
    rightCenter,
  } from "./alga_api.js";
  import { d } from "./alga_canvas.js";

  // make things crispy
  const dpr = window.devicePixelRatio;
  const cw = 300;
  const ch = 300;
  c.width = cw * dpr;
  c.height = ch * dpr;
  c.style.width = cw + "px";
  c.style.height = ch + "px";
  ctx.scale(dpr, dpr);

  const {
    draw,
    Box,
    Outline,
    DraggableBox,
    DraggableOutline,
    deleteDrawable,
    Text,
    Line,
  } = d(ctx);

  const b1 = DraggableBox("yellowgreen");
  const b2 = DraggableBox("orangered");
  const b3 = DraggableBox("violet");
  const b4 = DraggableBox("cornflowerblue");

  b2.left = b1.right + 5;
  b4.left = b3.right + 5;

  const g1 = Outline(b1, b2);
  const g2 = Outline(b3, b4);

  g2.top = g1.bottom.plus(15);

  g1.top = 20;
  g1.left = 20;
  Line(g1.centerBottom, g2.centerTop);

  function anim() {
    requestAnimationFrame(anim);
    ctx.clearRect(0, 0, c.width, c.height);
    draw();
  }
  anim();
</script>
<br />
<pre
  style="
    font-size: 14px;
    background: white;
    padding: 12px;
    border-radius: 0 18px 18px 18px;
    outline: 1px solid var(--main-color);
  "
>
// imports and canvas set-up are not shown in this code

const b1 = DraggableBox("yellowgreen");
const b2 = DraggableBox("orangered");
const b3 = DraggableBox("violet");
const b4 = DraggableBox("cornflowerblue");
<span style='color: orangered'>b2.left = b1.right + 5; //one-time set</span>
<span style='color: orangered'>b4.left = b3.right + 5; //one-time set</span>
const g1 = Outline(b1, b2);
const g2 = Outline(b3, b4);
<span style='color: var(--main-color)'>g2.top = g1.bottom.plus(15); //set and create relationship</span>
<span style='color: orangered'>g1.leftTop = [20, 20]; //one-time set</span>
Line(g1.centerBottom, g2.centerTop);
</pre>
<hr />
<canvas
  id="c"
  height="700"
  width="700"
  style="
    background: white;
    border-radius: 18px;
    outline: 1px solid var(--main-color);
  "
></canvas>
<script type="module">
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  import {
    Point,
    Group,
    spaceX,
    spaceY,
    eq,
    eq2,
    stackX,
    stackY,
    rel,
    lessThan,
  } from "../../2025_5/alga/alga_api.js";
  import { d } from "../../2025_5/alga/alga_canvas.js";

  // make things crispy
  const dpr = window.devicePixelRatio;
  const h = c.height;
  const w = c.width;
  c.width = w * dpr;
  c.height = h * dpr;
  c.style.width = w + "px";
  c.style.height = h + "px";
  ctx.scale(dpr, dpr);

  const {
    draw,
    Box,
    Outline,
    Arrow,
    DraggableBox,
    DraggableOutline,
    deleteDrawable,
    Text,
    Line,
    DropzoneBox,
    mouse,
    getArrows,
    isPointInside,
  } = d(ctx);

  const txtInit = DraggableBox();
  const caretRoot = Box("LightGray");
  let txtL = Group(txtInit);

  let txtHead = txtInit;

  txtInit.leftTop = [250, 200];

  let caretAr = Arrow(caretRoot.leftTop, txtHead.leftTop);

  Arrow(txtL.leftBottom, txtHead.leftBottom);

  caretRoot.left = txtL.left - 20;
  caretRoot.bottom = txtL.top - 20;

  // next:
  // - better text rendering
  // - backspace (deleting object from group)
  // - left and right careting (along Arrows somehow?)
  const outline = DraggableOutline(txtL, caretRoot);
  let me = outline;
  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && e.shiftKey) {
      eval(buildStr());
      return;
    }
    if (e.key === "Enter") {
      txtL = getPrev(txtHead)[1];

      const newTxtInit = DraggableBox("red", 10, 10);
      const newTxtL = Group(newTxtInit);
      stackY(5, 0)(txtL, newTxtL);

      Arrow(txtHead.centerBottom, newTxtInit.centerTop);
      txtL = newTxtL;
      outline.add(txtL);
      txtHead = newTxtInit;
      deleteDrawable(caretAr);

      newTxtInit.text = "\n";

      Arrow(txtL.leftBottom, txtHead.leftBottom);

      caretAr = Arrow(caretRoot.leftTop, txtHead.leftTop);
    } else if (e.key.length === 1) {
      txtHead = getNext(caretRoot);
      const newHead = Text(e.key);
      stackX(3)(txtHead, newHead);

      txtL = getPrev(txtHead)[1];

      txtL.add(newHead);
      Arrow(txtHead.rightCenter, newHead.leftCenter);
      Arrow(txtL.leftBottom, newHead.leftBottom);
      txtHead = newHead;
      deleteDrawable(caretAr);
      caretAr = Arrow(caretRoot.leftTop, txtHead.leftTop);
    } else if (e.key === "ArrowLeft") {
      const a = getPrev(getNext(caretRoot))[0];
      console.log("a", a);
      deleteDrawable(caretAr);
      caretAr = Arrow(caretRoot.leftTop, a.leftTop);
    } else if (e.key === "ArrowRight") {
      const a = getNext(getNext(caretRoot));
      if (!a) return;
      console.log("a", a);
      deleteDrawable(caretAr);
      caretAr = Arrow(caretRoot.leftTop, a.leftTop);
    } else if (e.key === "ArrowUp") {
      txtHead = getNext(caretRoot);
      const newHead = DropzoneBox("gray");
      stackX(3)(txtHead, newHead);

      txtL = getPrev(txtHead)[1];

      txtL.add(newHead);
      Arrow(txtHead.rightCenter, newHead.leftCenter);
      Arrow(txtL.leftBottom, newHead.leftBottom);
      txtHead = newHead;
      deleteDrawable(caretAr);
      caretAr = Arrow(caretRoot.leftTop, txtHead.leftTop);
    }
  });
  const buildStr = () => {
    let cur = txtInit;
    let str = "";
    while (cur) {
      str += cur.text ?? "";
      cur = getNext(cur);
    }
    return str;
  };
  const getPrev = (i2) =>
    getArrows()
      .filter((a) => i2 === a.to[0].interval2)
      .map((i) => i.from[0].interval2);
  const getNext = (i2) =>
    getArrows().filter((a) => i2 === a.from[0].interval2)[0]?.to[0].interval2;

  const makeInteractiveSwitchDiagram = () => {
    const l = Box("black", 20, 20);
    const r = Box("white", 20, 20);
    const dd = DraggableOutline(stackX(0)(l, r));
    dd.leftTop = [100, 100];
    c.addEventListener("mousedown", (e) => {
      if (isPointInside(mouse, dd)) {
        let savedColor = l.color;
        l.color = r.color;
        r.color = savedColor;
      }
    });
  };
  makeInteractiveSwitchDiagram();

  // what if this text was in a group and the group auto-expanded?

  const exp = (numD, expD) => {
    eq2(numD.rightTop, expD.leftCenter);
    return Group(numD, expD);
  };
  const FRAC_GAP = 8;
  const frac = (numD, denD) => {
    const g = stackY(FRAC_GAP)(numD, denD);
    const l = Line();
    l.left = g.left;
    l.right = g.right;
    l.top = numD.bottom.plus(FRAC_GAP / 2);
    l.bottom = l.top;
    return g;
  };
  const sum = (topD, bottomD, rightD) => {
    const Σ = Text("Σ", 40);
    stackX()(Σ, rightD);
    stackY(3)(topD, Σ);
    stackY(5)(Σ, bottomD);
    return Group(Σ, topD, bottomD, rightD);
  };
  const op =
    (opStr = "+") =>
    (leftD, rightD) => {
      const opD = Text(opStr, 30);
      return stackX()(leftD, opD, rightD);
    };

  const g = stackX(0)(
    Text("ζ(s) = "),
    sum(
      Text("∞", 22),
      Text("n=0"),
      frac(Text("1"), exp(Text("n"), Text("s", 12)))
    )
  );
  DraggableOutline(g);
  g.leftTop = [30, 30];

  const boundingExperimentF = () => {
    const b1 = DraggableBox("yellowgreen");
    const b2 = DraggableBox("orangered");
    const b3 = DraggableBox("violet");
    const b4 = DraggableBox("cornflowerblue");
    b2.left = 20;
    b4.left = 20;
    const g1 = Outline(b1, b2);
    const g2 = Outline(b3, b4);
    const boundingExperiment = spaceY(20)(g1, g2);
    Line(g1.centerBottom, g2.centerTop);
    DraggableOutline(boundingExperiment);
    boundingExperiment.left = 30;
    boundingExperiment.top = 130;
  };
  boundingExperimentF();

  const dagNode = (...sts) => {
    const node = DraggableBox("orange");
    node.t = node;
    node.next = sts.map((st) => st.t);

    for (const subt of sts) Line(node.centerBottom, subt.t.centerTop);

    const subts = sts.filter((subt) => !subt.parent);
    if (subts.length === 0) return node;
    for (const subt of subts) subt.parent = node;

    const subtsBox = spaceX(20)(...subts);
    eq(subtsBox.left, node.left);

    const res = spaceY(30)(node, Group(...subts));
    res.t = node;

    return res;
  };

  // actually a DAG
  const minNode = dagNode();
  const subDag1 = dagNode(dagNode(dagNode(minNode), dagNode(minNode)));
  const subDag2 = dagNode(dagNode(dagNode(minNode), dagNode(minNode)));
  const myDag = dagNode(
    dagNode(subDag1),
    dagNode(subDag1),
    dagNode(subDag1, subDag2)
  );

  DraggableOutline(myDag);
  myDag.left = 30;
  myDag.top = 230;

  const a0 = DraggableBox("orange");
  const b0 = DraggableBox("orange");
  const b1 = DraggableBox("orange");
  const b2 = DraggableBox("orange");
  const c0 = DraggableBox("orange");
  const c1 = DraggableBox("orange");
  Arrow(a0.centerTop, b0.centerTop);
  Arrow(a0.centerTop, b1.centerTop);
  Arrow(a0.centerTop, b2.centerTop);
  Arrow(b0.centerTop, c0.centerTop);
  Arrow(b1.centerTop, c0.centerTop);
  Arrow(b2.centerTop, c0.centerTop);
  Arrow(b2.centerTop, c1.centerTop);
  Arrow(b1.centerTop, c1.centerTop);

  DraggableOutline(a0, b0, b1, b2, c0, c1).leftTop = [300, 20];

  spaceX(22.5)(b0, b1, b2);
  spaceX(55)(c0, c1);
  a0.left = b0.left;
  b0.left = c0.left;
  spaceY()(a0, Group(b0, b1, b2));
  spaceY()(Group(b0, b1, b2), c0);
  spaceY()(Group(b1, b2), c1);

  const m00 = DraggableBox("yellowgreen");
  const m10 = DraggableBox("salmon");
  const m11 = DraggableBox("goldenrod");
  Outline(Group(m10, m11)).left = Outline(m00).right.plus(10);
  m10.top = 600;
  m11.top += 20;
  DraggableOutline(m00, m11).top = 500;

  const D = DraggableBox;
  const tt0 = D("red");
  const tt02 = D("orangered");
  const tt1 = D("red");
  const tt12 = D("orangered");
  const tt2 = D("red");
  const tt22 = D("orangered");
  const gg0 = Group(tt0, tt02);
  const gg1 = Group(tt1, tt12);
  const gg2 = Group(tt2, tt22);
  gg0.left = gg1.right.plus(15);
  gg1.left = gg2.right.plus(15);
  const ggg = DraggableOutline(tt0, tt1);
  tt1.left = 500;
  tt02.left = 500;
  tt12.left = 500;
  tt22.left = 500;
  tt2.top = 200;
  tt1.top = 200;
  tt0.top = 200;

  const bb1 = DraggableBox("yellowgreen");
  const bb2 = DraggableBox("crimson");
  const bb22 = DraggableBox("orange");
  bb22.top = 18;
  const bb3 = DraggableBox("violet");

  lessThan(bb1.x.r.plus(10), bb2.x.l);
  lessThan(bb1.x.r.plus(10), bb22.x.l);
  lessThan(bb2.x.r.plus(10), bb3.x.l);
  lessThan(bb22.x.r.plus(10), bb3.x.l);
  lessThan(bb2.y.r.plus(10), bb1.y.l);
  lessThan(bb2.y.r.plus(10), bb3.y.l);
  lessThan(bb1.y.r.plus(10), bb22.y.l);
  lessThan(bb3.y.r.plus(10), bb22.y.l);

  const bbg = DraggableOutline(bb1, bb2, bb22, bb3);
  bbg.top = 300;
  bbg.left = 300;

  addEventListener("keydown", (e) => {
    if (e.key === "s") {
      const l = DropzoneBox("LightGray", 40, 40);
      const r = DropzoneBox("LightGray", 40, 40);
      exp(l, r).leftTop = mouse;
    }
    if (e.key === "d") {
      const l = DropzoneBox("LightGray", 40, 40);
      const r = DropzoneBox("LightGray", 40, 40);
      op()(l, r).leftTop = mouse;
    }
    if (e.key === "f") {
      const num = DropzoneBox("LightGray", 40, 40);
      const denom = DropzoneBox("LightGray", 40, 40);
      frac(num, denom).leftTop = mouse;
    }
    if (e.key === "g") {
      sum(
        DropzoneBox("LightGray", 40, 40),
        DropzoneBox("LightGray", 40, 40),
        DropzoneBox("LightGray", 40, 40)
      ).leftTop = mouse;
    }
  });

  function anim() {
    requestAnimationFrame(anim);
    ctx.clearRect(0, 0, c.width, c.height);
    draw();
  }
  anim();
</script>
